/**
 * 그래픽 용어
 * Vertex: 노드
 * Edge: 노드사이틔 연결
 * Weighted/Unweighted 가중(edge에 값이 없음)/비가중(edge에 값없음)
 * Directed/Undirected 방향/양방향
 *
 * 구글 맵 각 포인트마다 거리가 다름 > 가중, 양방향그래프
 * 일방통행이면 가중,방향그래프
 *
 * 인스타그램 소셜 네트워크에서 관계에 값을 부여할수있음
 * 좋아요를 많이 했다던지 > 가중, 양방향그래프
 *
 * Representing a Graph
 *
 * 인접행렬  Adjacency Matrix
 *    A  B
 * A  0  1
 * B  1  0
 *
 * 인접 리스트  Adjacency List
 *  숫자일 떄, idx 활용
 *  [
 *   0  [1,5],
 *   1  [0,1]
 *  ]
 *
 * 숫자가 아닌 것들일 때, 문자열이거나..: 해시 맵 활용
 * {
 *  A: ['B', 'F'],
 *  B: ['A', 'C']
 * }
 *
 * 인접행렬 vs 인접 리스트의 BIG O
 *
 * add vertex : O(1) | O(|V^|) >
 * // 리스트는 정점이 더해져도  간선과 정점 개수에 비례해서 증가 (간선의 개수에 비례)
 * // 행열 2차원 구조니까 버텍스 추가시 열,행 한줄씩 추가해야함  // V는 vertex 개수
 * 데이터가 퍼져있고 간선이 많지않으면 행렬을 사용하지 않는게 나음
 *
 * 인접리스트
 * 간선이 많지 않고 퍼져있는 그래프에서 더 적은 공간을 차지한다.
 * 모든 간선을 확인하는게 빠르다
 * 특정 간선이 존재하는 것을 확인하는게 느리다 (Query O(|V| + |E|))
 *  A 와 D의 간선 > A를 먼저 찾고 A값을 모두 순회해서 찾아야한다. , 엣비와 버텍스 의 개수에 따라 다름
 *
 * 인접행렬
 * 모든 간선을 순회하는게 느리다. :간선을 확인하고 싶으면 모든 간선에 대해 루프를 돌아서 찾아야한다. (존재 하지 않는것도 저장하니까)
 * 특정 간선이 존재하는 것을 확인하는게 빠르다 (Query O(1))
 *  A와 D의 간선 > 행렬에서 바로 확인가능
 *
 * *** 행렬이 리스트보다 퍼저있는 데이터 찾을때 불리, 특정 간선 확인할 떄는 빠름 ***
 *
 * *** 인접 리스트에 대해 더 잘 알아두자 ***
 * 실제 데이터들은 퍼져있는 경우가 더 많음
 */
